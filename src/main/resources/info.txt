三目运算符换成位运算，如 (x < y ? 1 : 0) → -((x-y)>>31)&1，消除分支
JVM 的 JIT 对“小常量计数”的循环会自动展开

~i 常被当成 “i != -1” 的超短写法
奇偶判断：x & 1 == 1 ⇔ 奇数
交换两数：a ^= b; b ^= a; a ^= b;
快速幂：x << n 等价 x * 2ⁿ，x >> n 等价 x // 2ⁿ

BigInteger base = new BigInteger("7");
BigInteger exp  = new BigInteger("2025");
BigInteger mod  = new BigInteger("1000000007");
System.out.println(base.modPow(exp, mod)); // 7^2025 % 1e9+7

static long qpow(long a, long b, long mod) {
    long res = 1L;
    a %= mod;
    while (b > 0) {
        if ((b & 1) == 1) res = res * a % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return res;
}


蒙哥马利规约 = 用移位+乘法代替除法，让大数模乘飞起，是快速幂底层加速器。
precompute: R = 2^k , R⁻¹ mod p , p' = (-p⁻¹) mod R

function mont_reduce(T):        // T = aR*bR = abR²
    m = (T mod R) * p' mod R    // 低位乘一次
    t = (T + m*p) >> k          // 右移代替除 p
    if t ≥ p: t -= p            // 最终归一
    return t                    // = abR mod p  （仍在域内）

链式前向星 边的静态单链表 边e，结构体对象，可省
一维数组模拟单链表 静态单链表 顶点v，整数

    public static boolean isNaN(float v) {
        return (v != v);
    }

    int i = 0;
    int a = n++ + ++n;;   // 合法，等价于 (i++) + (++i)


$HOME/ac-lib/
├── data-structure/
│   ├── unionfind.hpp
│   ├── fenwick.hpp
│   ├── segmenttree.hpp
├── graph/
│   ├── dinic.hpp
│   ├── scc.hpp
├── string/
│   ├── kmp.hpp
│   ├── sam.hpp
└── template.cpp          // 空白 main，已 include 所有常用头

并查集（路径压缩 + 按秩）
栈式撤销并查集
Fenwick / 树状数组（单点、区间、二维）
线段树（区间加、区间最值、懒标记、离散化）
稀疏表 ST 表（静态 RMQ）
网络流 Dinic（当前弧优化、多路增广）
SCC（Tarjan / Kosaraju）
后缀自动机 SAM（线建、拓扑序、endpos 统计）
凸包 / 半平面交（计算几何）
多项式 FFT/NTT（ rarely 用，但必须有）

Java 板子时，把小函数写成 private static final，JIT 会自动内联，性能足够。
SegmentTree（线段树）：万能区间结构，支持加、乘、最值、历史版本等
