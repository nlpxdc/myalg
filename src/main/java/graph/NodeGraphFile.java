package graph;

import java.util.Set;

//第一自己视角 和树节点一样的定义
//节点定义 类似树节点，这里只关心节点顶点，不关心边和权重，因为不影响整体结构
//以身入局，行走的角度
//所以这里也不是真正的一维，而是一种嵌套表示的方式，分维，可以叠加屡次到很高维，叠加一次，就是二维，就是图，就是邻接表示，叠加多次，就是变成更高维度了？
//一维数组其实也可以，就像完全二叉树，但是这里只能有一个一维数组，不能有第二个一维数组，但就是会浪费空间？完全乱说，直觉不对
//因为有互相嵌套，不像树有规则制止，所以没法用一维数组来表示，放弃，因为会互相嵌套，循环依赖
//因为这个抽象的定义，可以在更高维度也是这么表示的，互相嵌套
class NodeGraphApp {
    public static void main(String[] args) {
        System.out.println("aa");
    }
}

//自递归定义 定义无向工程有向，因为递归自身？简单图 权重是边的权重，点没有权重
//如果有向怎么表示？下面那种，固定边权都是1，就不能是自递归定义了，自递归定义就是无向的
//应为不关心边权，所以只关心节点自身的关联，所以可以自递归定义
//工程定义上带方向
class UnWeightedArcNode {
    int nodeKey;
    //可以带点权
//    int nodeWeight;
    //无向，但是定义接口儿子，有点有向意思，可以有指回去的指针，但是不代表有向，只是容易回溯的手段而已
    //这里其实默认带方向了，工程上的，如果写无向，那么要对称的同时维护
    Set<UnWeightedArcNode> neighbourNodeSet;
}

//--------------------------------------------------

//互相嵌套，互相依赖

//如果无向的表示，必定是有一个对称的，共轭的？要同时维护，有向可以表示无向，无向不太能表示有向，多了一个维度
class WeightedArc {
//    int arcKey; //计算属性 上一个出度的node的nodeKey，和相邻节点的node的nodeKey决定，带方向，如果是无向图，nodeKey就是集合，不讲顺序，或者像上面一样，直接没有
    int arcWeight;
    //这里其实默认带方向了，看怎么定义，可以出，其实也可以是入，都是等价的没有优劣，总会有各自的坎，但是一般是出，约定俗成
    WeightedArcNode neighbourNode;
}

// 不是无向，是有向！ 简单图 非自递归定义，节点含边（这个边也是对应一个节点的带权表示，key依旧是关键，weight次要），不是节点含自身节点
//weight都等于1，就是有向无权图，因为关心边的权，所以就必须有边定义，就不能是自递归定义了
class WeightedArcNode {
    int nodeKey;
//    int nodeWeight;
    Set<WeightedArc> neighbourArcSet;
}
