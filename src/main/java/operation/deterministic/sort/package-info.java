package operation.deterministic.sort;

//pivot的选取的讲究，原则上一个pivot能最好对半分
//每个值都不同的情况下，pivot的具体值的选取讲究，为了避免极端情况的最坏，让最坏更好，不是让平均更好
// pivot对半分，最左，最右 最中间，斐波那契数列？选的是idx，选出的基准值pivot value，看运气能分成啥样，这里分析就要用到概率
//再嵌入式系统，讲究实时操作系统，对最坏敏感的，必须考虑最坏复杂度，并用可接受的算法，同时尽可能的减小常数操作，毕竟2倍 3倍 10倍，也是很客观的常数翻倍
//针对枚举值，值的数量本身很少，但是数量可能又很多，需要用到三段，两个pivot，可以相等，pivot小大可以相等，那么中间段就是一个值
//荷兰三色旗，两个pivot，三段

//最好事先清楚数据的大致类型分布或者范围分布，这样根据实际的情况做选择
//1. 先看数据值范围的分布和是否有序等，又是概率论。2.然后再看是否可以排序修改，是否可以原地修改 3.再决定算法大类和策略大类
//4. 然后实现时，看是否可以只用基本类型，还是引用类型，再具体选择存储结构设计
//5. 是否对最坏敏感？common，以大体为重，那么看avg的算法复杂度的下界。如果对最坏敏感，绝对不能慢，否则灾难的，那么看worst case的复杂度下界外
//6. 看看在工程实践上，进行不同算法类型的组合，去是配不同数据规模时，或者不同算法阶段时的最优算法。道道整体效果最好
//7. 最后用统计方式，对算法内部的关键参数调优，让常数逼近最小

//可以参考jdk，或其他语言官方库，三方库的具体实现，有哪些具体技巧以及其目的所在
