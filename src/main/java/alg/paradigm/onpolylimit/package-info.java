package alg.paradigm.onpolylimit;

//本质都是nested，特殊性质下likeflat

//explicit
//依赖前置结果
//从顶向下分解 递归 需要记忆化前置结果
//从底向上聚合 填表 初始化记录表格

//基于状态空间的搜索
//隐式的组合问题，组合排列，都最终可以转化成显式的图
//组合问题其实就是一个状态空间，枚举空间而已
//只是组合问题在转化成图的时候，有的状态太多，枚举太多，不好弄而已，尤其自身的限制规律
//但是本质上是可以套用图的算法的

//原基准复杂度 O(n的多次放多项式) O(cpowern) 或更大 O(n!) 或更更大O(n的n次方)
//一般针对图或组合排列，能省则省，能少则少，把条件下的不必要不可能的去掉不遍历，减小状态空间，优化实际平均
//含阶乘
//属于a(A)问题，analysis问题，耗时长，
//非独立split，一般解最优问题，关键状态转移，依赖前一个或者前多个
// 可以数据结构化，有模板方法，有通用套路，图论
// 一题一套路组合，排列（部分排列，全排列）
//一般有关联的切分，最优性原理，最优子结构，dp没有无后效性
//贪心加上贪心选择，有无后效性
//思想对应套路，对应代码模板，嵌套循环

//相比静态规划，一定访问，dp动态规划，在嵌套循环里，慢慢切掉不可能路径，不访问了
//这是一种思想，具体怎么切的实现方式还有很多
//也是dp，一种特殊的dp，拥有一定规律law，可以简化dp的流程，直接导致更加少的路径，需要有数学规律的支撑证明

//最优 系统设计 精准 常见 准实时？t+0 t+e 满足贪心选择性质
//多需要预处理

//dp greedy是思想，也就是cut，切割，剪切，greedy更严格，要数学证明
//回溯backtrack，a* ida*等是具体实现方式

//限制条件，嵌入模板代码中，
// 比较一个是固定死的规则调济安
//一个是比较比当前最优值更优